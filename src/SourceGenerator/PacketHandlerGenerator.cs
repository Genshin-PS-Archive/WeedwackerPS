#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;

namespace Weedwacker.SourceGenerator
{
	[Generator]
	public class HandlerSourceGenerator : IIncrementalGenerator
	{
#if DEBUG
		private static int _counter;
#endif
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			if (Debugger.IsAttached)
			{
				Debugger.Launch();
			}
			IncrementalValueProvider<ImmutableArray<IMethodSymbol>> handlers = context.SyntaxProvider.CreateSyntaxProvider(IsPacketHandler, GetMethodTypeOrNull)
						.Combine(context.CompilationProvider)
						.WithComparer(new MethodNameComparer())
						.Select((w, cancelToken) => w.Item1)
						.Collect();

			context.RegisterSourceOutput(handlers, GenerateCode);
		}
		private static bool IsPacketHandler(
			SyntaxNode syntaxNode,
			CancellationToken cancellationToken)
		{
			if (syntaxNode is not AttributeSyntax attribute)
				return false;

			string? name = (attribute.Name as IdentifierNameSyntax)?.Identifier.Text;

			return name == "OpCode" || name == "OpCodeAttribute";
		}
		private static IMethodSymbol GetMethodTypeOrNull(
			GeneratorSyntaxContext context,
			CancellationToken cancellationToken)
		{
			AttributeSyntax attributeSyntax = (AttributeSyntax)context.Node;

			// "attribute.Parent" is "AttributeListSyntax"
			// "attribute.Parent.Parent" is a C# fragment the attributes are applied to
			IMethodSymbol symbol = (IMethodSymbol)context.SemanticModel.GetDeclaredSymbol(attributeSyntax.Parent?.Parent as MethodDeclarationSyntax);

			return symbol;
		}
		private static void GenerateCode(
			SourceProductionContext context,
			ImmutableArray<IMethodSymbol> handlers)
		{
			if (handlers.IsDefaultOrEmpty) return;
			string source =
#if DEBUG
				@"// Counter: {Interlocked.Increment(ref _counter)}" +
#endif
$@"// <auto-generated/>
	using Google.Protobuf;
	using Weedwacker.GameServer.Enums;
	using Weedwacker.Shared.Network.Proto;
	using Weedwacker.Shared.Utils;

	namespace Weedwacker.GameServer;

	internal partial class Connection
	{{
		public delegate Task Handler(byte[] header, byte[] payload);	
		public Handler? GetHandler(ushort opcode)
		{{
			return opcode switch
			{{
	";

			StringBuilder sb = new(source);

			foreach (IMethodSymbol method in handlers)
			{
				AttributeData attr = method.GetAttributes().First(w => w.AttributeClass.Name == "OpCodeAttribute");
				ushort opcode = (ushort)attr.ConstructorArguments.First().Value;
				sb.Append(CreateDelegate(opcode, method.Name));
			}


			sb.Append($@"
				_ => null,
			}};
		}}
	}}
	");
			// Add the source code to the compilation
			context.AddSource($"ConnectionHandlers.g.cs", sb.ToString());
		}

		private static string CreateDelegate(ushort opcode, string handlerName)
		{
			return $"				{opcode} => {handlerName},\n";
		}
	}

	class MethodNameComparer : IEqualityComparer<(IMethodSymbol Node, Compilation compilation)>
	{
		public bool Equals(
		   (IMethodSymbol Node, Compilation compilation) x,
		   (IMethodSymbol Node, Compilation compilation) y)
		{
			return x.Node.Name.Equals(y.Node.Name);
		}

		public int GetHashCode((IMethodSymbol Node, Compilation compilation) obj)
		{
			return obj.Node.Name.GetHashCode();
		}
	}
}